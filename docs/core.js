function new_xmlHTTP()
создается объект xmlHTTPRequest

function htmlspecialchars(html)
экренирует кое-какие html-сущности

function isArray( obj )
аналогично PHP

function $i(a)
ищет по id внутри документа


function async_post(uri,data,callback)
создает xmlHTTP и отправляет по адресу uri запрос методом POST с данными data, callback ставится на изменеие статуса

function async_get(uri,callback)
создает xmlHTTP и отправляет по адресу uri запрос методом GET, callback ставится на изменеие статуса

function async_put(uri,data,callback)
создает xmlHTTP и отправляет по адресу uri запрос методом PUT с данными data, callback ставится на изменеие статуса

function async_delete(uri,callback)
создает xmlHTTP и отправляет по адресу uri запрос методом DELETE, callback ставится на изменеие статуса


============================================- resizer_object -================================================
resizer_object - класс для обработки изменения размера блочных элементов методом перетаскивания

создается 1 экземпляр window.resizer
ставятся свои обработчики на mouseup, mousedown, mousemove для document

меняет width и height у всего, имеющего id.match(/.*(resizeable|resize_style)/)
причем если id.match(/.*(resizeablex|resize_stylex)/) меняется только width
       если id.match(/.*(resizeabley|resize_styley)/) меняется только height
рекомендуется ставить такой id контейнеру div, а уже внутрь него помещать то, размер чего предполагается менять
в стиле контейнера стоит предусмотреть широкую рамку, которую можно будет тягать мышью
на отпускание кнопки мыши можно повесить сохранение размеров ajaxом или каким-либо другим способом и какие-нибудь другие действия (поменять положения/размеры элементов, на которые этот div наехал)
событие отпускания мыши вызывается даже если браузер не успел перещитать размеры объектов и кнопка была фактически отпущена над чем-то другим
если id совпадает с /resizeable.*/ то меняется style данного объекта(действует только на него)
если id совпадает с /resize_style.*/ то меняется class данного объекта(действует на все с таким же class)




============================================- change_sender -================================================
change_sender - класс для асинхронной отправки значений форм по мере ввода
создается 1 экземпляр window.chse
для нормальной работы с текстовымы полями (<input type=text>, <textarea>) нужно где-то в документе вызвать
	setInterval('chse.timerch(false);',1000);
	где 1000 - промежуток времени для проверки на изменение значения
при использовании предполагается вызывать метод change_sender.activatemon(object) при получении полем фокуса
и метод change_sender.deactivatemon(ref) или change_sender.latedeactivate(ref) при потере фокуса
при изменении содержимого полей checkbox,radiobutton,select предполагается  вызывать change_sender.timerch(true)

change_sender.monitored=new Array();
массив с отслеживаемыми объектами - в него помещаются дополненные объекты, передаваемые в качестве параметра change_sender.activatemon. В нормальных ситуациях должен присутствовать 1 объект. В сложных случаях лучше использовать скрытые поля, вычисляемые на основании содержимого видимых полей или фейковые. Обработка ненормальных ситуаций неполная - будет глючить так или этак

change_sender.sending=false;
признак наличия активного xmlHTTP

change_sender.callback_uri='';
адрес по умолчанию, на который отправляется запрос методом POST если не переопределено в вызове activatemon

change_sender.queue=new Array();
буфер для запросов на случай перегруженного сервера/медленного канала

change_sender.timeout=null;
идентификатор таймаута создаваемого при вызове latedeactivate

change_sender.fetchfuncs=[];
сюда предполагается (обязательно нужно чтобы работало) помещать функции вида
function (object)
{
	if (object.objtype=='...')return function(){return this.obj.value}
	....
}
возвращаемые этим методом функции становятся методами объекта, передаваемого activatemon при помещении его в monitored
вызываются в контексте объекта, передаваемого activatemon с целью получения значения для передачи на сервер в случае
изменения содержимого объекта и положительном результате вызова функции из checkerfuncs
!!!!!!!!!!!!можно получить в обратных запросах undefined если не найдется подходящей функции !!!!!!!!!!


change_sender.checkerfuncs=[];
сюда предполагается (обязательно нужно чтобы работало) помещать функции вида
function (object)
{
	if (object.objtype=='...')return function(){if(this.obj.value>....)return true;return false}
	....
}
возвращаемые этим методом функции становятся методами объекта, передаваемого activatemon при помещении его в monitored
вызываются в контексте объекта, передаваемого activatemon с целью проврки/вычисления значения для передачи на сервер в случае
изменения содержимого объекта перед вызовом функции из checkerfuncs. При возврате false/null/0 прерывают отправку
!!!!!!!!!!!!!отправка не пойдет вообще, если не найдется подходящей функции!!!!!!!!!!

change_sender.activatemon = function(def)
предполагается вызывать при получении полем фокуса ввода
def - объект, имеющий обязательные поля:
def.obj - ссылка на объект, изменение которого нужно начать отслеживать
def.static - передается методом post в таком виде (def.static + '=' + def.fetchfunc())
необязательные поля:
def.uri - заменяет адрес на который идет отправка
любые другие поля, по которым можно правильно идентифицировать объект при вызове genfetch/genchecker и присвоить ему правильный метод fetch/checker
метод вызывает genfetch и genchecker для определения значений fetch/checker
метод снимает таймаут вызова deactivatemon если def.obj совпадает с полем obj любого элемента массива monitored


change_sender.latedeactivate = function(obj)
предполагается вызывать при потере объектом фокуса (для объектов из нескольких полей)
вызывает deactivatemon с задержкой 100 мс

change_sender.deactivatemon = function(obj)
предполагается вызывать при потере объектом фокуса (для объектов из одного поля)
вызывает timerch(true) для принудительной отправки при потере фокуса
удаляет элементы массива monitored с совпадающим полем obj


change_sender.timerch = function(force)
вызывается при возможном изменении объекта
вызывает для всех объектов в monitored checker() и если возвращено true запускает отправку
если в данный момент идет отправка добавляет в очередь/замещает, если последняя отправка в очереди с таким же obj



change_sender.send_async = function(d)
выполняет собственно отправку
отправляет по адресу d.uri/callback_uri/'' методом post строку (d.static + '=' + d.val)
по завершении запроса идет проверка на наличие в очереди отложенных запросов и отправка первого из них

change_sender.genfetch = function(o)
по очереди вызывает функции из fetchfuncs с параметром o
в случае получения не null возвращает полученное значение
(может стоит сразу присваивать o.fetch ????????)


change_sender.genchecker = function(o)
по очереди вызывает функции из checkerfuncs с параметром o
в случае получения не null возвращает полученное значение
(может стоит сразу присваивать o.checker ????????)


